#include "TL45.h"
#include "TL45TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "TL45Subtarget.h"
//#include "TL45InstrInfo.h"

#define DEBUG_TYPE "lc2200-isel"

using namespace llvm;

class TL45DAGToDAGISel : public SelectionDAGISel {
	const TL45Subtarget *Subtarget;
 public:
	explicit TL45DAGToDAGISel(TL45TargetMachine &TM, CodeGenOpt::Level OptLevel)
		: SelectionDAGISel(TM, OptLevel) {}

  StringRef getPassName() const override {
    return "TL45 DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<TL45Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

	void Select(SDNode *N) override;

//	bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

  bool SelectAddrFI(SDValue Addr, SDValue &Base);

  // Include the pieces autogenerated from the target description.
  #include "TL45GenDAGISel.inc"
};

static SDNode *selectImm(SelectionDAG *CurDAG, const SDLoc &DL, int64_t Imm,
                         MVT XLenVT) {

  SDValue ZeroReg = CurDAG->getRegister(TL45::r0, XLenVT);

  if (isInt<16>(Imm)) {
    SDValue SDImm = CurDAG->getTargetConstant(Imm, DL, XLenVT);

    return CurDAG->getMachineNode(TL45::ADDI, DL, XLenVT, ZeroReg, SDImm);
  } else if (isInt<32>(Imm)) {
    SDValue SDImm = CurDAG->getTargetConstant(Imm, DL, XLenVT);

    return CurDAG->getMachineNode(TL45::ADD32, DL, XLenVT, ZeroReg, SDImm);
  }

  llvm_unreachable("cannot select immediate that doesn't fit in imm20");
}

void TL45DAGToDAGISel::Select(SDNode *Node) {
// If we have a custom node, we have already selected.
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.
  unsigned Opcode = Node->getOpcode();
  MVT XLenVT = MVT::i32;
  SDLoc DL(Node);
  EVT VT = Node->getValueType(0);

  switch (Opcode) {
    case ISD::Constant: {
      auto ConstNode = cast<ConstantSDNode>(Node);
      if (VT == XLenVT && ConstNode->isNullValue()) {
        SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),TL45::r0, XLenVT);
        ReplaceNode(Node, New.getNode());
        return;
      }
      int64_t Imm = ConstNode->getSExtValue();
      if (XLenVT == MVT::i32) {
        ReplaceNode(Node, selectImm(CurDAG, SDLoc(Node), Imm, XLenVT));
        return;
      }
      break;
    }
    case ISD::FrameIndex: {
      SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
      int FI = cast<FrameIndexSDNode>(Node)->getIndex();
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
      ReplaceNode(Node, CurDAG->getMachineNode(TL45::ADDI, DL, VT, TFI, Imm));
      return;
    }
//    case ISD::SRL: {
//      if (!Subtarget->is64Bit())
//        break;
//      SDValue Op0 = Node->getOperand(0);
//      SDValue Op1 = Node->getOperand(1);
//      uint64_t Mask;
//      // Match (srl (and val, mask), imm) where the result would be a
//      // zero-extended 32-bit integer. i.e. the mask is 0xffffffff or the result
//      // is equivalent to this (SimplifyDemandedBits may have removed lower bits
//      // from the mask that aren't necessary due to the right-shifting).
//      if (Op1.getOpcode() == ISD::Constant &&
//          isConstantMask(Op0.getNode(), Mask)) {
//        uint64_t ShAmt = cast<ConstantSDNode>(Op1.getNode())->getZExtValue();
//
//        if ((Mask | maskTrailingOnes<uint64_t>(ShAmt)) == 0xffffffff) {
//          SDValue ShAmtVal =
//                  CurDAG->getTargetConstant(ShAmt, SDLoc(Node), XLenVT);
//          CurDAG->SelectNodeTo(Node, RISCV::SRLIW, XLenVT, Op0.getOperand(0),
//                               ShAmtVal);
//          return;
//        }
//      }
//      break;
//    }
//    case RISCVISD::READ_CYCLE_WIDE:
//      assert(!Subtarget->is64Bit() && "READ_CYCLE_WIDE is only used on riscv32");
//
//      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::ReadCycleWide, DL, MVT::i32,
//                                               MVT::i32, MVT::Other,
//                                               Node->getOperand(0)));
//      return;
  }

  // Select the default instruction.
  SelectCode(Node);
}

bool TL45DAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    return true;
  }
  return false;
}

//bool TL45DAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset) {
//	if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
//		Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), getTargetLowering()->getPointerTy());
//		Offset = CurDAG->getTargetConstant(0, MVT::i32);
//		return true;
//	}
//	if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
//		Addr.getOpcode() == ISD::TargetGlobalAddress ||
//		Addr.getOpcode() == ISD::TargetGlobalTLSAddress) {
//		return false; // direct calls.
//	}
//	Base = Addr;
//	Offset = CurDAG->getTargetConstant(0, MVT::i32);
//	return true;
//}
//
//
FunctionPass *llvm::createTL45ISelDag(TL45TargetMachine &TM, CodeGenOpt::Level OptLevel) {
	return new TL45DAGToDAGISel(TM, OptLevel);
}